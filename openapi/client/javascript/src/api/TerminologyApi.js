/**
 * West Coast Informatics Terminology API
 * API documentation for the <a href=\"https://www.westcoastinformatics.com\">West Coast Informatics</a> terminology server API.<p>Request a 30-day bearer token from <a href=\"mailto:info@westcoastinformatics.com\">info@westcoastinformatics.com</a>.</p> <p>For full documentation on this service, please visit our wiki page at <a href=\"https://wci-wiki.atlassian.net/wiki/spaces/TSV2\">https://wci-wiki.atlassian.net/wiki/spaces/TSV2</a>.</p>
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@westcoastinformatics.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import Atom from '../model/Atom';
import Concept from '../model/Concept';
import ConceptTreePosition from '../model/ConceptTreePosition';
import Mapset from '../model/Mapset';
import ResultListConcept from '../model/ResultListConcept';
import ResultListConceptRelationship from '../model/ResultListConceptRelationship';
import ResultListConceptTreePosition from '../model/ResultListConceptTreePosition';
import ResultListMapping from '../model/ResultListMapping';
import ResultListMapset from '../model/ResultListMapset';
import ResultListSubset from '../model/ResultListSubset';
import Subset from '../model/Subset';
import Terminology from '../model/Terminology';

/**
* Terminology service.
* @module api/TerminologyApi
* @version 1.0.0
*/
export default class TerminologyApi {

    /**
    * Constructs a new TerminologyApi. 
    * @alias module:api/TerminologyApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }


    /**
     * Callback function to receive the result of the addSynonym operation.
     * @callback module:api/TerminologyApi~addSynonymCallback
     * @param {String} error Error message, if any.
     * @param {module:model/Atom} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Add synonym
     * Add synonym with specified parameters
     * @param {String} terminology terminology, e.g. SNOMEDCT_US
     * @param {String} code code, e.g. 80891009
     * @param {Object} opts Optional parameters
     * @param {String} [name] synonym name, e.g. \"test name\"
     * @param {String} [termType] term type, e.g. INDEX_SY
     * @param {Object.<String, {String: String}>} [requestBody] 
     * @param {module:api/TerminologyApi~addSynonymCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/Atom}
     */
    addSynonym(terminology, code, opts, callback) {
      opts = opts || {};
      let postBody = opts['requestBody'];
      // verify the required parameter 'terminology' is set
      if (terminology === undefined || terminology === null) {
        throw new Error("Missing the required parameter 'terminology' when calling addSynonym");
      }
      // verify the required parameter 'code' is set
      if (code === undefined || code === null) {
        throw new Error("Missing the required parameter 'code' when calling addSynonym");
      }

      let pathParams = {
        'terminology': terminology,
        'code': code
      };
      let queryParams = {
        'name': opts['name'],
        'termType': opts['termType']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = ['application/json', 'application/xml'];
      let accepts = ['application/json', 'application/xml'];
      let returnType = Atom;
      return this.apiClient.callApi(
        '/terminology/concept/{terminology}/{code}/atom', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the autocompleteConcepts1 operation.
     * @callback module:api/TerminologyApi~autocompleteConcepts1Callback
     * @param {String} error Error message, if any.
     * @param {module:model/ResultListConcept} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Autocomplete
     * Find concepts for a type-ahead search field
     * @param {String} terminology terminology, e.g. SNOMEDCT_US
     * @param {Object} opts Optional parameters
     * @param {String} [query] 
     * @param {String} [expression] 
     * @param {String} [clause] 
     * @param {Number} [limit] 
     * @param {module:api/TerminologyApi~autocompleteConcepts1Callback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ResultListConcept}
     */
    autocompleteConcepts1(terminology, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'terminology' is set
      if (terminology === undefined || terminology === null) {
        throw new Error("Missing the required parameter 'terminology' when calling autocompleteConcepts1");
      }

      let pathParams = {
        'terminology': terminology
      };
      let queryParams = {
        'query': opts['query'],
        'expression': opts['expression'],
        'clause': opts['clause'],
        'limit': opts['limit']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ResultListConcept;
      return this.apiClient.callApi(
        '/terminology/concept/{terminology}/autocomplete', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the findConcepts operation.
     * @callback module:api/TerminologyApi~findConceptsCallback
     * @param {String} error Error message, if any.
     * @param {module:model/ResultListConcept} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Find concepts
     * Find concepts matching the specified search criteria
     * @param {String} terminology terminology, e.g. SNOMEDCT_US
     * @param {Object} opts Optional parameters
     * @param {String} [query] query, e.g. \"heart attack\"
     * @param {String} [expression] ECL Expression, e.g. <<80891009
     * @param {Number} [offset] offset, e.g. 0
     * @param {Number} [limit] limit, e.g. 10
     * @param {Boolean} [ascending] ascending, e.g. true
     * @param {String} [sort] sort field, e.g. code
     * @param {String} [handler] search handler, e.g. STANDARD, EXACT, NGRAM
     * @param {String} [resolver] graph resolver, e.g. DEFAULT, MIN
     * @param {Boolean} [active] active only, e.g. true
     * @param {Boolean} [leaf] leaf nodes only, e.g. false
     * @param {module:api/TerminologyApi~findConceptsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ResultListConcept}
     */
    findConcepts(terminology, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'terminology' is set
      if (terminology === undefined || terminology === null) {
        throw new Error("Missing the required parameter 'terminology' when calling findConcepts");
      }

      let pathParams = {
        'terminology': terminology
      };
      let queryParams = {
        'query': opts['query'],
        'expression': opts['expression'],
        'offset': opts['offset'],
        'limit': opts['limit'],
        'ascending': opts['ascending'],
        'sort': opts['sort'],
        'handler': opts['handler'],
        'resolver': opts['resolver'],
        'active': opts['active'],
        'leaf': opts['leaf']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ResultListConcept;
      return this.apiClient.callApi(
        '/terminology/concept/{terminology}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the findConcepts2 operation.
     * @callback module:api/TerminologyApi~findConcepts2Callback
     * @param {String} error Error message, if any.
     * @param {module:model/ResultListConcept} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Find concepts (across all terminologies)
     * Find concepts matching the specified search criteria
     * @param {Object} opts Optional parameters
     * @param {String} [query] query, e.g. \"heart attack\"
     * @param {Number} [offset] offset, e.g. 0
     * @param {Number} [limit] limit, e.g. 10
     * @param {Boolean} [ascending] ascending, e.g. true
     * @param {String} [sort] sort field, e.g. code
     * @param {String} [handler] search handler, e.g. STANDARD, EXACT, NGRAM
     * @param {String} [resolver] graph resolver, e.g. DEFAULT, MIN
     * @param {Boolean} [active] active only, e.g. true
     * @param {Boolean} [leaf] leaf nodes only, e.g. false
     * @param {module:api/TerminologyApi~findConcepts2Callback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ResultListConcept}
     */
    findConcepts2(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'query': opts['query'],
        'offset': opts['offset'],
        'limit': opts['limit'],
        'ascending': opts['ascending'],
        'sort': opts['sort'],
        'handler': opts['handler'],
        'resolver': opts['resolver'],
        'active': opts['active'],
        'leaf': opts['leaf']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ResultListConcept;
      return this.apiClient.callApi(
        '/terminology/concept', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the findMappings1 operation.
     * @callback module:api/TerminologyApi~findMappings1Callback
     * @param {String} error Error message, if any.
     * @param {module:model/ResultListMapping} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Find mappings
     * Find mappings for the specified terminology and code
     * @param {String} terminology terminology, e.g. SNOMEDCT_US
     * @param {String} code concept code, e.g. 6011000124106
     * @param {Object} opts Optional parameters
     * @param {String} [query] 
     * @param {Number} [offset] 
     * @param {Number} [limit] 
     * @param {Boolean} [ascending] 
     * @param {String} [sort] 
     * @param {module:api/TerminologyApi~findMappings1Callback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ResultListMapping}
     */
    findMappings1(terminology, code, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'terminology' is set
      if (terminology === undefined || terminology === null) {
        throw new Error("Missing the required parameter 'terminology' when calling findMappings1");
      }
      // verify the required parameter 'code' is set
      if (code === undefined || code === null) {
        throw new Error("Missing the required parameter 'code' when calling findMappings1");
      }

      let pathParams = {
        'terminology': terminology,
        'code': code
      };
      let queryParams = {
        'query': opts['query'],
        'offset': opts['offset'],
        'limit': opts['limit'],
        'ascending': opts['ascending'],
        'sort': opts['sort']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ResultListMapping;
      return this.apiClient.callApi(
        '/terminology/mapset/{terminology}/{code}/mapping', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the findSubsetMemberships1 operation.
     * @callback module:api/TerminologyApi~findSubsetMemberships1Callback
     * @param {String} error Error message, if any.
     * @param {module:model/ResultListSubset} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get concept subset memberships
     * Get subsets that the specified terminology and code are a member of
     * @param {String} terminology terminology, e.g. SNOMEDCT_US
     * @param {String} code concept code, e.g. 723264001
     * @param {module:api/TerminologyApi~findSubsetMemberships1Callback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ResultListSubset}
     */
    findSubsetMemberships1(terminology, code, callback) {
      let postBody = null;
      // verify the required parameter 'terminology' is set
      if (terminology === undefined || terminology === null) {
        throw new Error("Missing the required parameter 'terminology' when calling findSubsetMemberships1");
      }
      // verify the required parameter 'code' is set
      if (code === undefined || code === null) {
        throw new Error("Missing the required parameter 'code' when calling findSubsetMemberships1");
      }

      let pathParams = {
        'terminology': terminology,
        'code': code
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ResultListSubset;
      return this.apiClient.callApi(
        '/terminology/concept/{terminology}/{code}/subsets', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the findTreePositionChildren1 operation.
     * @callback module:api/TerminologyApi~findTreePositionChildren1Callback
     * @param {String} error Error message, if any.
     * @param {module:model/ResultListConceptTreePosition} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Find tree position children
     * Find the child tree position nodes for the specified terminology and code
     * @param {String} terminology terminology, e.g. SNOMEDCT_US
     * @param {String} code concept code, e.g. 71388002
     * @param {Object} opts Optional parameters
     * @param {Number} [offset] 
     * @param {Number} [limit] 
     * @param {Boolean} [ascending] 
     * @param {String} [sort] 
     * @param {module:api/TerminologyApi~findTreePositionChildren1Callback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ResultListConceptTreePosition}
     */
    findTreePositionChildren1(terminology, code, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'terminology' is set
      if (terminology === undefined || terminology === null) {
        throw new Error("Missing the required parameter 'terminology' when calling findTreePositionChildren1");
      }
      // verify the required parameter 'code' is set
      if (code === undefined || code === null) {
        throw new Error("Missing the required parameter 'code' when calling findTreePositionChildren1");
      }

      let pathParams = {
        'terminology': terminology,
        'code': code
      };
      let queryParams = {
        'offset': opts['offset'],
        'limit': opts['limit'],
        'ascending': opts['ascending'],
        'sort': opts['sort']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ResultListConceptTreePosition;
      return this.apiClient.callApi(
        '/terminology/concept/{terminology}/{code}/trees/children', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the findTreePositions1 operation.
     * @callback module:api/TerminologyApi~findTreePositions1Callback
     * @param {String} error Error message, if any.
     * @param {module:model/ResultListConceptTreePosition} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Find tree positions
     * Find tree positions for the specified terminology and code
     * @param {String} terminology terminology, e.g. SNOMEDCT_US
     * @param {String} code concept code, e.g. 71388002
     * @param {Object} opts Optional parameters
     * @param {Number} [offset] 
     * @param {Number} [limit] 
     * @param {Boolean} [ascending] 
     * @param {String} [sort] 
     * @param {module:api/TerminologyApi~findTreePositions1Callback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ResultListConceptTreePosition}
     */
    findTreePositions1(terminology, code, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'terminology' is set
      if (terminology === undefined || terminology === null) {
        throw new Error("Missing the required parameter 'terminology' when calling findTreePositions1");
      }
      // verify the required parameter 'code' is set
      if (code === undefined || code === null) {
        throw new Error("Missing the required parameter 'code' when calling findTreePositions1");
      }

      let pathParams = {
        'terminology': terminology,
        'code': code
      };
      let queryParams = {
        'offset': opts['offset'],
        'limit': opts['limit'],
        'ascending': opts['ascending'],
        'sort': opts['sort']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ResultListConceptTreePosition;
      return this.apiClient.callApi(
        '/terminology/concept/{terminology}/{code}/trees', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getConcept1 operation.
     * @callback module:api/TerminologyApi~getConcept1Callback
     * @param {String} error Error message, if any.
     * @param {module:model/Concept} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get concept
     * Get concept object for the specified terminology, code, and resolver
     * @param {String} terminology terminology, e.g. SNOMEDCT_US
     * @param {String} code concept code, e.g. 71388002
     * @param {Object} opts Optional parameters
     * @param {String} [resolver] graph resolver, e.g. DEFAULT, MIN
     * @param {module:api/TerminologyApi~getConcept1Callback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/Concept}
     */
    getConcept1(terminology, code, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'terminology' is set
      if (terminology === undefined || terminology === null) {
        throw new Error("Missing the required parameter 'terminology' when calling getConcept1");
      }
      // verify the required parameter 'code' is set
      if (code === undefined || code === null) {
        throw new Error("Missing the required parameter 'code' when calling getConcept1");
      }

      let pathParams = {
        'terminology': terminology,
        'code': code
      };
      let queryParams = {
        'resolver': opts['resolver']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Concept;
      return this.apiClient.callApi(
        '/terminology/concept/{terminology}/{code}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getConceptMappings1 operation.
     * @callback module:api/TerminologyApi~getConceptMappings1Callback
     * @param {String} error Error message, if any.
     * @param {module:model/ResultListMapping} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get concept mappings
     * Get mappings that the specified terminology and code are mapped from
     * @param {String} terminology terminology, e.g. SNOMEDCT_US
     * @param {String} code concept code, e.g. 283231003
     * @param {module:api/TerminologyApi~getConceptMappings1Callback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ResultListMapping}
     */
    getConceptMappings1(terminology, code, callback) {
      let postBody = null;
      // verify the required parameter 'terminology' is set
      if (terminology === undefined || terminology === null) {
        throw new Error("Missing the required parameter 'terminology' when calling getConceptMappings1");
      }
      // verify the required parameter 'code' is set
      if (code === undefined || code === null) {
        throw new Error("Missing the required parameter 'code' when calling getConceptMappings1");
      }

      let pathParams = {
        'terminology': terminology,
        'code': code
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ResultListMapping;
      return this.apiClient.callApi(
        '/terminology/concept/{terminology}/{code}/mapping', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getConfigProperties1 operation.
     * @callback module:api/TerminologyApi~getConfigProperties1Callback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get properties
     * Get configuration information used to drive certain UI functionality
     * @param {module:api/TerminologyApi~getConfigProperties1Callback} callback The callback function, accepting three arguments: error, data, response
     */
    getConfigProperties1(callback) {
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/terminology/properties', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getMapset1 operation.
     * @callback module:api/TerminologyApi~getMapset1Callback
     * @param {String} error Error message, if any.
     * @param {module:model/Mapset} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get mapset
     * Get mapsets for the specified terminology and code
     * @param {String} terminology terminology, e.g. SNOMEDCT_US
     * @param {String} code concept code, e.g. 6011000124106
     * @param {module:api/TerminologyApi~getMapset1Callback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/Mapset}
     */
    getMapset1(terminology, code, callback) {
      let postBody = null;
      // verify the required parameter 'terminology' is set
      if (terminology === undefined || terminology === null) {
        throw new Error("Missing the required parameter 'terminology' when calling getMapset1");
      }
      // verify the required parameter 'code' is set
      if (code === undefined || code === null) {
        throw new Error("Missing the required parameter 'code' when calling getMapset1");
      }

      let pathParams = {
        'terminology': terminology,
        'code': code
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Mapset;
      return this.apiClient.callApi(
        '/terminology/mapset/{terminology}/{code}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getMapsets1 operation.
     * @callback module:api/TerminologyApi~getMapsets1Callback
     * @param {String} error Error message, if any.
     * @param {module:model/ResultListMapset} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get mapsets
     * Get all mapsets for the specified terminology
     * @param {String} terminology terminology, e.g. SNOMEDCT_US
     * @param {module:api/TerminologyApi~getMapsets1Callback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ResultListMapset}
     */
    getMapsets1(terminology, callback) {
      let postBody = null;
      // verify the required parameter 'terminology' is set
      if (terminology === undefined || terminology === null) {
        throw new Error("Missing the required parameter 'terminology' when calling getMapsets1");
      }

      let pathParams = {
        'terminology': terminology
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ResultListMapset;
      return this.apiClient.callApi(
        '/terminology/mapset/{terminology}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getRelationships1 operation.
     * @callback module:api/TerminologyApi~getRelationships1Callback
     * @param {String} error Error message, if any.
     * @param {module:model/ResultListConceptRelationship} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get concept relationships
     * Get relationships for for specified terminology and code
     * @param {String} terminology terminology, e.g. SNOMEDCT_US
     * @param {String} code concept code, e.g. 71388002
     * @param {Object} opts Optional parameters
     * @param {Number} [offset] 
     * @param {Number} [limit = 100)] 
     * @param {Boolean} [ascending] 
     * @param {String} [sort] 
     * @param {Boolean} [inverse] 
     * @param {Boolean} [active] 
     * @param {String} [filter] 
     * @param {module:api/TerminologyApi~getRelationships1Callback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ResultListConceptRelationship}
     */
    getRelationships1(terminology, code, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'terminology' is set
      if (terminology === undefined || terminology === null) {
        throw new Error("Missing the required parameter 'terminology' when calling getRelationships1");
      }
      // verify the required parameter 'code' is set
      if (code === undefined || code === null) {
        throw new Error("Missing the required parameter 'code' when calling getRelationships1");
      }

      let pathParams = {
        'terminology': terminology,
        'code': code
      };
      let queryParams = {
        'offset': opts['offset'],
        'limit': opts['limit'],
        'ascending': opts['ascending'],
        'sort': opts['sort'],
        'inverse': opts['inverse'],
        'active': opts['active'],
        'filter': opts['filter']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ResultListConceptRelationship;
      return this.apiClient.callApi(
        '/terminology/concept/{terminology}/{code}/relationships', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getSubset1 operation.
     * @callback module:api/TerminologyApi~getSubset1Callback
     * @param {String} error Error message, if any.
     * @param {module:model/Subset} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get subset
     * Get subsets for the specified terminology and code
     * @param {String} terminology terminology, e.g. SNOMEDCT_US
     * @param {String} code concept code, e.g. 723264001
     * @param {module:api/TerminologyApi~getSubset1Callback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/Subset}
     */
    getSubset1(terminology, code, callback) {
      let postBody = null;
      // verify the required parameter 'terminology' is set
      if (terminology === undefined || terminology === null) {
        throw new Error("Missing the required parameter 'terminology' when calling getSubset1");
      }
      // verify the required parameter 'code' is set
      if (code === undefined || code === null) {
        throw new Error("Missing the required parameter 'code' when calling getSubset1");
      }

      let pathParams = {
        'terminology': terminology,
        'code': code
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Subset;
      return this.apiClient.callApi(
        '/terminology/subset/{terminology}/{code}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getSubsets1 operation.
     * @callback module:api/TerminologyApi~getSubsets1Callback
     * @param {String} error Error message, if any.
     * @param {module:model/ResultListSubset} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get subsets
     * Get all subsets for the specified terminology
     * @param {String} terminology terminology, e.g. SNOMEDCT_US
     * @param {module:api/TerminologyApi~getSubsets1Callback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ResultListSubset}
     */
    getSubsets1(terminology, callback) {
      let postBody = null;
      // verify the required parameter 'terminology' is set
      if (terminology === undefined || terminology === null) {
        throw new Error("Missing the required parameter 'terminology' when calling getSubsets1");
      }

      let pathParams = {
        'terminology': terminology
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ResultListSubset;
      return this.apiClient.callApi(
        '/terminology/subset/{terminology}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getSubtree1 operation.
     * @callback module:api/TerminologyApi~getSubtree1Callback
     * @param {String} error Error message, if any.
     * @param {module:model/ConceptTreePosition} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get subtree
     * Get the subtree for the specified terminology and code
     * @param {String} terminology terminology, e.g. SNOMEDCT_US
     * @param {String} code concept code, e.g. 71388002
     * @param {Object} opts Optional parameters
     * @param {Number} [maxLevel] 
     * @param {module:api/TerminologyApi~getSubtree1Callback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ConceptTreePosition}
     */
    getSubtree1(terminology, code, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'terminology' is set
      if (terminology === undefined || terminology === null) {
        throw new Error("Missing the required parameter 'terminology' when calling getSubtree1");
      }
      // verify the required parameter 'code' is set
      if (code === undefined || code === null) {
        throw new Error("Missing the required parameter 'code' when calling getSubtree1");
      }

      let pathParams = {
        'terminology': terminology,
        'code': code
      };
      let queryParams = {
        'maxLevel': opts['maxLevel']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ConceptTreePosition;
      return this.apiClient.callApi(
        '/terminology/concept/{terminology}/{code}/subtree', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getTerminologies1 operation.
     * @callback module:api/TerminologyApi~getTerminologies1Callback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/Terminology>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get terminologies
     * Get all terminologies
     * @param {module:api/TerminologyApi~getTerminologies1Callback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/Terminology>}
     */
    getTerminologies1(callback) {
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Terminology];
      return this.apiClient.callApi(
        '/terminology', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getTerminology1 operation.
     * @callback module:api/TerminologyApi~getTerminology1Callback
     * @param {String} error Error message, if any.
     * @param {module:model/Terminology} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get terminology
     * Get terminology object for the specified terminology
     * @param {String} terminology terminology, e.g. SNOMEDCT_US
     * @param {module:api/TerminologyApi~getTerminology1Callback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/Terminology}
     */
    getTerminology1(terminology, callback) {
      let postBody = null;
      // verify the required parameter 'terminology' is set
      if (terminology === undefined || terminology === null) {
        throw new Error("Missing the required parameter 'terminology' when calling getTerminology1");
      }

      let pathParams = {
        'terminology': terminology
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Terminology;
      return this.apiClient.callApi(
        '/terminology/{terminology}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getTerminologyMetadata1 operation.
     * @callback module:api/TerminologyApi~getTerminologyMetadata1Callback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get terminology metadata
     * Get map of terminology abbreviations to metadata for specified terminology
     * @param {String} terminology terminology, e.g. SNOMEDCT_US
     * @param {module:api/TerminologyApi~getTerminologyMetadata1Callback} callback The callback function, accepting three arguments: error, data, response
     */
    getTerminologyMetadata1(terminology, callback) {
      let postBody = null;
      // verify the required parameter 'terminology' is set
      if (terminology === undefined || terminology === null) {
        throw new Error("Missing the required parameter 'terminology' when calling getTerminologyMetadata1");
      }

      let pathParams = {
        'terminology': terminology
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/terminology/metadata/{terminology}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the resolveExpression1 operation.
     * @callback module:api/TerminologyApi~resolveExpression1Callback
     * @param {String} error Error message, if any.
     * @param {Array.<String>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Resolve expression
     * Get concept ids corresponding to thespecified terminology and expression. For more information on working with expressions, see <a href=\"https://github.com/WestCoastInformatics/wci-terminology-service-in-5-minutes/blob/master/doc/EXPRESSION.md\">https://github.com/WestCoastInformatics/wci-terminology-service-in-5-minutes/blob/master/doc/EXPRESSION.md</a>.
     * @param {String} terminology terminology, e.g. SNOMEDCT_US
     * @param {Object} opts Optional parameters
     * @param {String} [expression] 
     * @param {module:api/TerminologyApi~resolveExpression1Callback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<String>}
     */
    resolveExpression1(terminology, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'terminology' is set
      if (terminology === undefined || terminology === null) {
        throw new Error("Missing the required parameter 'terminology' when calling resolveExpression1");
      }

      let pathParams = {
        'terminology': terminology
      };
      let queryParams = {
        'expression': opts['expression']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ['String'];
      return this.apiClient.callApi(
        '/terminology/expr/{terminology}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }


}
