/*
West Coast Informatics Terminology API

API documentation for the <a href=\"https://www.westcoastinformatics.com\">West Coast Informatics</a> terminology server API.<p>Request a 30-day bearer token from <a href=\"mailto:info@westcoastinformatics.com\">info@westcoastinformatics.com</a>.</p> <p>For full documentation on this service, please visit our wiki page at <a href=\"https://wci-wiki.atlassian.net/wiki/spaces/TSV2\">https://wci-wiki.atlassian.net/wiki/spaces/TSV2</a>.</p>

API version: 1.0.0
Contact: info@westcoastinformatics.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// TerminologyAPIService TerminologyAPI service
type TerminologyAPIService service

type ApiAddSynonymRequest struct {
	ctx context.Context
	ApiService *TerminologyAPIService
	terminology string
	code string
	name *string
	termType *string
	requestBody *map[string]string
}

// synonym name, e.g. \&quot;test name\&quot;
func (r ApiAddSynonymRequest) Name(name string) ApiAddSynonymRequest {
	r.name = &name
	return r
}

// term type, e.g. INDEX_SY
func (r ApiAddSynonymRequest) TermType(termType string) ApiAddSynonymRequest {
	r.termType = &termType
	return r
}

func (r ApiAddSynonymRequest) RequestBody(requestBody map[string]string) ApiAddSynonymRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiAddSynonymRequest) Execute() (*Atom, *http.Response, error) {
	return r.ApiService.AddSynonymExecute(r)
}

/*
AddSynonym Add synonym

Add synonym with specified parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology terminology, e.g. SNOMEDCT_US
 @param code code, e.g. 80891009
 @return ApiAddSynonymRequest
*/
func (a *TerminologyAPIService) AddSynonym(ctx context.Context, terminology string, code string) ApiAddSynonymRequest {
	return ApiAddSynonymRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return Atom
func (a *TerminologyAPIService) AddSynonymExecute(r ApiAddSynonymRequest) (*Atom, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Atom
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminologyAPIService.AddSynonym")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminology/concept/{terminology}/{code}/atom"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.termType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "termType", r.termType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAutocompleteConcepts1Request struct {
	ctx context.Context
	ApiService *TerminologyAPIService
	terminology string
	query *string
	expression *string
	clause *string
	limit *int32
}

func (r ApiAutocompleteConcepts1Request) Query(query string) ApiAutocompleteConcepts1Request {
	r.query = &query
	return r
}

func (r ApiAutocompleteConcepts1Request) Expression(expression string) ApiAutocompleteConcepts1Request {
	r.expression = &expression
	return r
}

func (r ApiAutocompleteConcepts1Request) Clause(clause string) ApiAutocompleteConcepts1Request {
	r.clause = &clause
	return r
}

func (r ApiAutocompleteConcepts1Request) Limit(limit int32) ApiAutocompleteConcepts1Request {
	r.limit = &limit
	return r
}

func (r ApiAutocompleteConcepts1Request) Execute() (*ResultListConcept, *http.Response, error) {
	return r.ApiService.AutocompleteConcepts1Execute(r)
}

/*
AutocompleteConcepts1 Autocomplete

Find concepts for a type-ahead search field

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology terminology, e.g. SNOMEDCT_US
 @return ApiAutocompleteConcepts1Request
*/
func (a *TerminologyAPIService) AutocompleteConcepts1(ctx context.Context, terminology string) ApiAutocompleteConcepts1Request {
	return ApiAutocompleteConcepts1Request{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
	}
}

// Execute executes the request
//  @return ResultListConcept
func (a *TerminologyAPIService) AutocompleteConcepts1Execute(r ApiAutocompleteConcepts1Request) (*ResultListConcept, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultListConcept
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminologyAPIService.AutocompleteConcepts1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminology/concept/{terminology}/autocomplete"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.expression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expression", r.expression, "")
	}
	if r.clause != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clause", r.clause, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindConceptsRequest struct {
	ctx context.Context
	ApiService *TerminologyAPIService
	terminology string
	query *string
	expression *string
	offset *int32
	limit *int32
	ascending *bool
	sort *string
	handler *string
	resolver *string
	active *bool
	leaf *bool
}

// query, e.g. \&quot;heart attack\&quot;
func (r ApiFindConceptsRequest) Query(query string) ApiFindConceptsRequest {
	r.query = &query
	return r
}

// ECL Expression, e.g. &lt;&lt;80891009
func (r ApiFindConceptsRequest) Expression(expression string) ApiFindConceptsRequest {
	r.expression = &expression
	return r
}

// offset, e.g. 0
func (r ApiFindConceptsRequest) Offset(offset int32) ApiFindConceptsRequest {
	r.offset = &offset
	return r
}

// limit, e.g. 10
func (r ApiFindConceptsRequest) Limit(limit int32) ApiFindConceptsRequest {
	r.limit = &limit
	return r
}

// ascending, e.g. true
func (r ApiFindConceptsRequest) Ascending(ascending bool) ApiFindConceptsRequest {
	r.ascending = &ascending
	return r
}

// sort field, e.g. code
func (r ApiFindConceptsRequest) Sort(sort string) ApiFindConceptsRequest {
	r.sort = &sort
	return r
}

// search handler, e.g. STANDARD, EXACT, NGRAM
func (r ApiFindConceptsRequest) Handler(handler string) ApiFindConceptsRequest {
	r.handler = &handler
	return r
}

// graph resolver, e.g. DEFAULT, MIN
func (r ApiFindConceptsRequest) Resolver(resolver string) ApiFindConceptsRequest {
	r.resolver = &resolver
	return r
}

// active only, e.g. true
func (r ApiFindConceptsRequest) Active(active bool) ApiFindConceptsRequest {
	r.active = &active
	return r
}

// leaf nodes only, e.g. false
func (r ApiFindConceptsRequest) Leaf(leaf bool) ApiFindConceptsRequest {
	r.leaf = &leaf
	return r
}

func (r ApiFindConceptsRequest) Execute() (*ResultListConcept, *http.Response, error) {
	return r.ApiService.FindConceptsExecute(r)
}

/*
FindConcepts Find concepts

Find concepts matching the specified search criteria

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology terminology, e.g. SNOMEDCT_US
 @return ApiFindConceptsRequest
*/
func (a *TerminologyAPIService) FindConcepts(ctx context.Context, terminology string) ApiFindConceptsRequest {
	return ApiFindConceptsRequest{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
	}
}

// Execute executes the request
//  @return ResultListConcept
func (a *TerminologyAPIService) FindConceptsExecute(r ApiFindConceptsRequest) (*ResultListConcept, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultListConcept
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminologyAPIService.FindConcepts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminology/concept/{terminology}"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.expression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expression", r.expression, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.ascending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ascending", r.ascending, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.handler != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "handler", r.handler, "")
	}
	if r.resolver != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resolver", r.resolver, "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	}
	if r.leaf != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "leaf", r.leaf, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindConcepts2Request struct {
	ctx context.Context
	ApiService *TerminologyAPIService
	query *string
	offset *int32
	limit *int32
	ascending *bool
	sort *string
	handler *string
	resolver *string
	active *bool
	leaf *bool
}

// query, e.g. \&quot;heart attack\&quot;
func (r ApiFindConcepts2Request) Query(query string) ApiFindConcepts2Request {
	r.query = &query
	return r
}

// offset, e.g. 0
func (r ApiFindConcepts2Request) Offset(offset int32) ApiFindConcepts2Request {
	r.offset = &offset
	return r
}

// limit, e.g. 10
func (r ApiFindConcepts2Request) Limit(limit int32) ApiFindConcepts2Request {
	r.limit = &limit
	return r
}

// ascending, e.g. true
func (r ApiFindConcepts2Request) Ascending(ascending bool) ApiFindConcepts2Request {
	r.ascending = &ascending
	return r
}

// sort field, e.g. code
func (r ApiFindConcepts2Request) Sort(sort string) ApiFindConcepts2Request {
	r.sort = &sort
	return r
}

// search handler, e.g. STANDARD, EXACT, NGRAM
func (r ApiFindConcepts2Request) Handler(handler string) ApiFindConcepts2Request {
	r.handler = &handler
	return r
}

// graph resolver, e.g. DEFAULT, MIN
func (r ApiFindConcepts2Request) Resolver(resolver string) ApiFindConcepts2Request {
	r.resolver = &resolver
	return r
}

// active only, e.g. true
func (r ApiFindConcepts2Request) Active(active bool) ApiFindConcepts2Request {
	r.active = &active
	return r
}

// leaf nodes only, e.g. false
func (r ApiFindConcepts2Request) Leaf(leaf bool) ApiFindConcepts2Request {
	r.leaf = &leaf
	return r
}

func (r ApiFindConcepts2Request) Execute() (*ResultListConcept, *http.Response, error) {
	return r.ApiService.FindConcepts2Execute(r)
}

/*
FindConcepts2 Find concepts (across all terminologies)

Find concepts matching the specified search criteria

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFindConcepts2Request
*/
func (a *TerminologyAPIService) FindConcepts2(ctx context.Context) ApiFindConcepts2Request {
	return ApiFindConcepts2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResultListConcept
func (a *TerminologyAPIService) FindConcepts2Execute(r ApiFindConcepts2Request) (*ResultListConcept, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultListConcept
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminologyAPIService.FindConcepts2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminology/concept"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.ascending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ascending", r.ascending, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.handler != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "handler", r.handler, "")
	}
	if r.resolver != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resolver", r.resolver, "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	}
	if r.leaf != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "leaf", r.leaf, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindMappings1Request struct {
	ctx context.Context
	ApiService *TerminologyAPIService
	terminology string
	code string
	query *string
	offset *int32
	limit *int32
	ascending *bool
	sort *string
}

func (r ApiFindMappings1Request) Query(query string) ApiFindMappings1Request {
	r.query = &query
	return r
}

func (r ApiFindMappings1Request) Offset(offset int32) ApiFindMappings1Request {
	r.offset = &offset
	return r
}

func (r ApiFindMappings1Request) Limit(limit int32) ApiFindMappings1Request {
	r.limit = &limit
	return r
}

func (r ApiFindMappings1Request) Ascending(ascending bool) ApiFindMappings1Request {
	r.ascending = &ascending
	return r
}

func (r ApiFindMappings1Request) Sort(sort string) ApiFindMappings1Request {
	r.sort = &sort
	return r
}

func (r ApiFindMappings1Request) Execute() (*ResultListMapping, *http.Response, error) {
	return r.ApiService.FindMappings1Execute(r)
}

/*
FindMappings1 Find mappings

Find mappings for the specified terminology and code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology terminology, e.g. SNOMEDCT_US
 @param code concept code, e.g. 6011000124106
 @return ApiFindMappings1Request
*/
func (a *TerminologyAPIService) FindMappings1(ctx context.Context, terminology string, code string) ApiFindMappings1Request {
	return ApiFindMappings1Request{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return ResultListMapping
func (a *TerminologyAPIService) FindMappings1Execute(r ApiFindMappings1Request) (*ResultListMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultListMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminologyAPIService.FindMappings1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminology/mapset/{terminology}/{code}/mapping"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.ascending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ascending", r.ascending, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindSubsetMemberships1Request struct {
	ctx context.Context
	ApiService *TerminologyAPIService
	terminology string
	code string
}

func (r ApiFindSubsetMemberships1Request) Execute() (*ResultListSubset, *http.Response, error) {
	return r.ApiService.FindSubsetMemberships1Execute(r)
}

/*
FindSubsetMemberships1 Get concept subset memberships

Get subsets that the specified terminology and code are a member of

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology terminology, e.g. SNOMEDCT_US
 @param code concept code, e.g. 723264001
 @return ApiFindSubsetMemberships1Request
*/
func (a *TerminologyAPIService) FindSubsetMemberships1(ctx context.Context, terminology string, code string) ApiFindSubsetMemberships1Request {
	return ApiFindSubsetMemberships1Request{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return ResultListSubset
func (a *TerminologyAPIService) FindSubsetMemberships1Execute(r ApiFindSubsetMemberships1Request) (*ResultListSubset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultListSubset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminologyAPIService.FindSubsetMemberships1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminology/concept/{terminology}/{code}/subsets"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindTreePositionChildren1Request struct {
	ctx context.Context
	ApiService *TerminologyAPIService
	terminology string
	code string
	offset *int32
	limit *int32
	ascending *bool
	sort *string
}

func (r ApiFindTreePositionChildren1Request) Offset(offset int32) ApiFindTreePositionChildren1Request {
	r.offset = &offset
	return r
}

func (r ApiFindTreePositionChildren1Request) Limit(limit int32) ApiFindTreePositionChildren1Request {
	r.limit = &limit
	return r
}

func (r ApiFindTreePositionChildren1Request) Ascending(ascending bool) ApiFindTreePositionChildren1Request {
	r.ascending = &ascending
	return r
}

func (r ApiFindTreePositionChildren1Request) Sort(sort string) ApiFindTreePositionChildren1Request {
	r.sort = &sort
	return r
}

func (r ApiFindTreePositionChildren1Request) Execute() (*ResultListConceptTreePosition, *http.Response, error) {
	return r.ApiService.FindTreePositionChildren1Execute(r)
}

/*
FindTreePositionChildren1 Find tree position children

Find the child tree position nodes for the specified terminology and code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology terminology, e.g. SNOMEDCT_US
 @param code concept code, e.g. 71388002
 @return ApiFindTreePositionChildren1Request
*/
func (a *TerminologyAPIService) FindTreePositionChildren1(ctx context.Context, terminology string, code string) ApiFindTreePositionChildren1Request {
	return ApiFindTreePositionChildren1Request{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return ResultListConceptTreePosition
func (a *TerminologyAPIService) FindTreePositionChildren1Execute(r ApiFindTreePositionChildren1Request) (*ResultListConceptTreePosition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultListConceptTreePosition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminologyAPIService.FindTreePositionChildren1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminology/concept/{terminology}/{code}/trees/children"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.ascending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ascending", r.ascending, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindTreePositions1Request struct {
	ctx context.Context
	ApiService *TerminologyAPIService
	terminology string
	code string
	offset *int32
	limit *int32
	ascending *bool
	sort *string
}

func (r ApiFindTreePositions1Request) Offset(offset int32) ApiFindTreePositions1Request {
	r.offset = &offset
	return r
}

func (r ApiFindTreePositions1Request) Limit(limit int32) ApiFindTreePositions1Request {
	r.limit = &limit
	return r
}

func (r ApiFindTreePositions1Request) Ascending(ascending bool) ApiFindTreePositions1Request {
	r.ascending = &ascending
	return r
}

func (r ApiFindTreePositions1Request) Sort(sort string) ApiFindTreePositions1Request {
	r.sort = &sort
	return r
}

func (r ApiFindTreePositions1Request) Execute() (*ResultListConceptTreePosition, *http.Response, error) {
	return r.ApiService.FindTreePositions1Execute(r)
}

/*
FindTreePositions1 Find tree positions

Find tree positions for the specified terminology and code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology terminology, e.g. SNOMEDCT_US
 @param code concept code, e.g. 71388002
 @return ApiFindTreePositions1Request
*/
func (a *TerminologyAPIService) FindTreePositions1(ctx context.Context, terminology string, code string) ApiFindTreePositions1Request {
	return ApiFindTreePositions1Request{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return ResultListConceptTreePosition
func (a *TerminologyAPIService) FindTreePositions1Execute(r ApiFindTreePositions1Request) (*ResultListConceptTreePosition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultListConceptTreePosition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminologyAPIService.FindTreePositions1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminology/concept/{terminology}/{code}/trees"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.ascending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ascending", r.ascending, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConcept1Request struct {
	ctx context.Context
	ApiService *TerminologyAPIService
	terminology string
	code string
	resolver *string
}

// graph resolver, e.g. DEFAULT, MIN
func (r ApiGetConcept1Request) Resolver(resolver string) ApiGetConcept1Request {
	r.resolver = &resolver
	return r
}

func (r ApiGetConcept1Request) Execute() (*Concept, *http.Response, error) {
	return r.ApiService.GetConcept1Execute(r)
}

/*
GetConcept1 Get concept

Get concept object for the specified terminology, code, and resolver

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology terminology, e.g. SNOMEDCT_US
 @param code concept code, e.g. 71388002
 @return ApiGetConcept1Request
*/
func (a *TerminologyAPIService) GetConcept1(ctx context.Context, terminology string, code string) ApiGetConcept1Request {
	return ApiGetConcept1Request{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return Concept
func (a *TerminologyAPIService) GetConcept1Execute(r ApiGetConcept1Request) (*Concept, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Concept
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminologyAPIService.GetConcept1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminology/concept/{terminology}/{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.resolver != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resolver", r.resolver, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConceptMappings1Request struct {
	ctx context.Context
	ApiService *TerminologyAPIService
	terminology string
	code string
}

func (r ApiGetConceptMappings1Request) Execute() (*ResultListMapping, *http.Response, error) {
	return r.ApiService.GetConceptMappings1Execute(r)
}

/*
GetConceptMappings1 Get concept mappings

Get mappings that the specified terminology and code are mapped from

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology terminology, e.g. SNOMEDCT_US
 @param code concept code, e.g. 283231003
 @return ApiGetConceptMappings1Request
*/
func (a *TerminologyAPIService) GetConceptMappings1(ctx context.Context, terminology string, code string) ApiGetConceptMappings1Request {
	return ApiGetConceptMappings1Request{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return ResultListMapping
func (a *TerminologyAPIService) GetConceptMappings1Execute(r ApiGetConceptMappings1Request) (*ResultListMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultListMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminologyAPIService.GetConceptMappings1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminology/concept/{terminology}/{code}/mapping"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConfigProperties1Request struct {
	ctx context.Context
	ApiService *TerminologyAPIService
}

func (r ApiGetConfigProperties1Request) Execute() (*http.Response, error) {
	return r.ApiService.GetConfigProperties1Execute(r)
}

/*
GetConfigProperties1 Get properties

Get configuration information used to drive certain UI functionality

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConfigProperties1Request
*/
func (a *TerminologyAPIService) GetConfigProperties1(ctx context.Context) ApiGetConfigProperties1Request {
	return ApiGetConfigProperties1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TerminologyAPIService) GetConfigProperties1Execute(r ApiGetConfigProperties1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminologyAPIService.GetConfigProperties1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminology/properties"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetMapset1Request struct {
	ctx context.Context
	ApiService *TerminologyAPIService
	terminology string
	code string
}

func (r ApiGetMapset1Request) Execute() (*Mapset, *http.Response, error) {
	return r.ApiService.GetMapset1Execute(r)
}

/*
GetMapset1 Get mapset

Get mapsets for the specified terminology and code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology terminology, e.g. SNOMEDCT_US
 @param code concept code, e.g. 6011000124106
 @return ApiGetMapset1Request
*/
func (a *TerminologyAPIService) GetMapset1(ctx context.Context, terminology string, code string) ApiGetMapset1Request {
	return ApiGetMapset1Request{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return Mapset
func (a *TerminologyAPIService) GetMapset1Execute(r ApiGetMapset1Request) (*Mapset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Mapset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminologyAPIService.GetMapset1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminology/mapset/{terminology}/{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMapsets1Request struct {
	ctx context.Context
	ApiService *TerminologyAPIService
	terminology string
}

func (r ApiGetMapsets1Request) Execute() (*ResultListMapset, *http.Response, error) {
	return r.ApiService.GetMapsets1Execute(r)
}

/*
GetMapsets1 Get mapsets

Get all mapsets for the specified terminology

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology terminology, e.g. SNOMEDCT_US
 @return ApiGetMapsets1Request
*/
func (a *TerminologyAPIService) GetMapsets1(ctx context.Context, terminology string) ApiGetMapsets1Request {
	return ApiGetMapsets1Request{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
	}
}

// Execute executes the request
//  @return ResultListMapset
func (a *TerminologyAPIService) GetMapsets1Execute(r ApiGetMapsets1Request) (*ResultListMapset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultListMapset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminologyAPIService.GetMapsets1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminology/mapset/{terminology}"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRelationships1Request struct {
	ctx context.Context
	ApiService *TerminologyAPIService
	terminology string
	code string
	offset *int32
	limit *int32
	ascending *bool
	sort *string
	inverse *bool
	active *bool
	filter *string
}

func (r ApiGetRelationships1Request) Offset(offset int32) ApiGetRelationships1Request {
	r.offset = &offset
	return r
}

func (r ApiGetRelationships1Request) Limit(limit int32) ApiGetRelationships1Request {
	r.limit = &limit
	return r
}

func (r ApiGetRelationships1Request) Ascending(ascending bool) ApiGetRelationships1Request {
	r.ascending = &ascending
	return r
}

func (r ApiGetRelationships1Request) Sort(sort string) ApiGetRelationships1Request {
	r.sort = &sort
	return r
}

func (r ApiGetRelationships1Request) Inverse(inverse bool) ApiGetRelationships1Request {
	r.inverse = &inverse
	return r
}

func (r ApiGetRelationships1Request) Active(active bool) ApiGetRelationships1Request {
	r.active = &active
	return r
}

func (r ApiGetRelationships1Request) Filter(filter string) ApiGetRelationships1Request {
	r.filter = &filter
	return r
}

func (r ApiGetRelationships1Request) Execute() (*ResultListConceptRelationship, *http.Response, error) {
	return r.ApiService.GetRelationships1Execute(r)
}

/*
GetRelationships1 Get concept relationships

Get relationships for for specified terminology and code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology terminology, e.g. SNOMEDCT_US
 @param code concept code, e.g. 71388002
 @return ApiGetRelationships1Request
*/
func (a *TerminologyAPIService) GetRelationships1(ctx context.Context, terminology string, code string) ApiGetRelationships1Request {
	return ApiGetRelationships1Request{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return ResultListConceptRelationship
func (a *TerminologyAPIService) GetRelationships1Execute(r ApiGetRelationships1Request) (*ResultListConceptRelationship, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultListConceptRelationship
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminologyAPIService.GetRelationships1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminology/concept/{terminology}/{code}/relationships"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.ascending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ascending", r.ascending, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubset1Request struct {
	ctx context.Context
	ApiService *TerminologyAPIService
	terminology string
	code string
}

func (r ApiGetSubset1Request) Execute() (*Subset, *http.Response, error) {
	return r.ApiService.GetSubset1Execute(r)
}

/*
GetSubset1 Get subset

Get subsets for the specified terminology and code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology terminology, e.g. SNOMEDCT_US
 @param code concept code, e.g. 723264001
 @return ApiGetSubset1Request
*/
func (a *TerminologyAPIService) GetSubset1(ctx context.Context, terminology string, code string) ApiGetSubset1Request {
	return ApiGetSubset1Request{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return Subset
func (a *TerminologyAPIService) GetSubset1Execute(r ApiGetSubset1Request) (*Subset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Subset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminologyAPIService.GetSubset1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminology/subset/{terminology}/{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubsets1Request struct {
	ctx context.Context
	ApiService *TerminologyAPIService
	terminology string
}

func (r ApiGetSubsets1Request) Execute() (*ResultListSubset, *http.Response, error) {
	return r.ApiService.GetSubsets1Execute(r)
}

/*
GetSubsets1 Get subsets

Get all subsets for the specified terminology

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology terminology, e.g. SNOMEDCT_US
 @return ApiGetSubsets1Request
*/
func (a *TerminologyAPIService) GetSubsets1(ctx context.Context, terminology string) ApiGetSubsets1Request {
	return ApiGetSubsets1Request{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
	}
}

// Execute executes the request
//  @return ResultListSubset
func (a *TerminologyAPIService) GetSubsets1Execute(r ApiGetSubsets1Request) (*ResultListSubset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultListSubset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminologyAPIService.GetSubsets1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminology/subset/{terminology}"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubtree1Request struct {
	ctx context.Context
	ApiService *TerminologyAPIService
	terminology string
	code string
	maxLevel *int32
}

func (r ApiGetSubtree1Request) MaxLevel(maxLevel int32) ApiGetSubtree1Request {
	r.maxLevel = &maxLevel
	return r
}

func (r ApiGetSubtree1Request) Execute() (*ConceptTreePosition, *http.Response, error) {
	return r.ApiService.GetSubtree1Execute(r)
}

/*
GetSubtree1 Get subtree

Get the subtree for the specified terminology and code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology terminology, e.g. SNOMEDCT_US
 @param code concept code, e.g. 71388002
 @return ApiGetSubtree1Request
*/
func (a *TerminologyAPIService) GetSubtree1(ctx context.Context, terminology string, code string) ApiGetSubtree1Request {
	return ApiGetSubtree1Request{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
		code: code,
	}
}

// Execute executes the request
//  @return ConceptTreePosition
func (a *TerminologyAPIService) GetSubtree1Execute(r ApiGetSubtree1Request) (*ConceptTreePosition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConceptTreePosition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminologyAPIService.GetSubtree1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminology/concept/{terminology}/{code}/subtree"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxLevel", r.maxLevel, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTerminologies1Request struct {
	ctx context.Context
	ApiService *TerminologyAPIService
}

func (r ApiGetTerminologies1Request) Execute() ([]Terminology, *http.Response, error) {
	return r.ApiService.GetTerminologies1Execute(r)
}

/*
GetTerminologies1 Get terminologies

Get all terminologies

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTerminologies1Request
*/
func (a *TerminologyAPIService) GetTerminologies1(ctx context.Context) ApiGetTerminologies1Request {
	return ApiGetTerminologies1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Terminology
func (a *TerminologyAPIService) GetTerminologies1Execute(r ApiGetTerminologies1Request) ([]Terminology, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Terminology
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminologyAPIService.GetTerminologies1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminology"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTerminology1Request struct {
	ctx context.Context
	ApiService *TerminologyAPIService
	terminology string
}

func (r ApiGetTerminology1Request) Execute() (*Terminology, *http.Response, error) {
	return r.ApiService.GetTerminology1Execute(r)
}

/*
GetTerminology1 Get terminology

Get terminology object for the specified terminology

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology terminology, e.g. SNOMEDCT_US
 @return ApiGetTerminology1Request
*/
func (a *TerminologyAPIService) GetTerminology1(ctx context.Context, terminology string) ApiGetTerminology1Request {
	return ApiGetTerminology1Request{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
	}
}

// Execute executes the request
//  @return Terminology
func (a *TerminologyAPIService) GetTerminology1Execute(r ApiGetTerminology1Request) (*Terminology, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Terminology
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminologyAPIService.GetTerminology1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminology/{terminology}"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTerminologyMetadata1Request struct {
	ctx context.Context
	ApiService *TerminologyAPIService
	terminology string
}

func (r ApiGetTerminologyMetadata1Request) Execute() (*http.Response, error) {
	return r.ApiService.GetTerminologyMetadata1Execute(r)
}

/*
GetTerminologyMetadata1 Get terminology metadata

Get map of terminology abbreviations to metadata for specified terminology

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology terminology, e.g. SNOMEDCT_US
 @return ApiGetTerminologyMetadata1Request
*/
func (a *TerminologyAPIService) GetTerminologyMetadata1(ctx context.Context, terminology string) ApiGetTerminologyMetadata1Request {
	return ApiGetTerminologyMetadata1Request{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
	}
}

// Execute executes the request
func (a *TerminologyAPIService) GetTerminologyMetadata1Execute(r ApiGetTerminologyMetadata1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminologyAPIService.GetTerminologyMetadata1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminology/metadata/{terminology}"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiResolveExpression1Request struct {
	ctx context.Context
	ApiService *TerminologyAPIService
	terminology string
	expression *string
}

func (r ApiResolveExpression1Request) Expression(expression string) ApiResolveExpression1Request {
	r.expression = &expression
	return r
}

func (r ApiResolveExpression1Request) Execute() ([]string, *http.Response, error) {
	return r.ApiService.ResolveExpression1Execute(r)
}

/*
ResolveExpression1 Resolve expression

Get concept ids corresponding to thespecified terminology and expression. For more information on working with expressions, see <a href="https://github.com/WestCoastInformatics/wci-terminology-service-in-5-minutes/blob/master/doc/EXPRESSION.md">https://github.com/WestCoastInformatics/wci-terminology-service-in-5-minutes/blob/master/doc/EXPRESSION.md</a>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param terminology terminology, e.g. SNOMEDCT_US
 @return ApiResolveExpression1Request
*/
func (a *TerminologyAPIService) ResolveExpression1(ctx context.Context, terminology string) ApiResolveExpression1Request {
	return ApiResolveExpression1Request{
		ApiService: a,
		ctx: ctx,
		terminology: terminology,
	}
}

// Execute executes the request
//  @return []string
func (a *TerminologyAPIService) ResolveExpression1Execute(r ApiResolveExpression1Request) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminologyAPIService.ResolveExpression1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminology/expr/{terminology}"
	localVarPath = strings.Replace(localVarPath, "{"+"terminology"+"}", url.PathEscape(parameterValueToString(r.terminology, "terminology")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expression", r.expression, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
